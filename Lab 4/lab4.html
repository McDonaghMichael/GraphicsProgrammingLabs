<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Canvas</title>
    <script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
    <style type="text/css">
        canvas {
            border: 1px solid grey;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none; /* This allows mouse events to pass through to the main canvas */
        }
    </style>
</head>

<body>

<h1>Michael McDonagh</h1>
<h3>G00421944@atu.ie</h3>
<canvas id="canvas-for-ball" width="400" height="300" style="z-index: 2"></canvas>
<canvas id="canvas-for-ball-overlay" width="400" height="300" style="position: absolute; top: 0; left: 0;"></canvas>


<script type="text/javascript">
    const canvas = document.getElementById("canvas-for-ball");
    const ctx = canvas.getContext("2d");

    const overlayCanvas = document.getElementById("canvas-for-ball-overlay");
    const overlayCtx = overlayCanvas.getContext("2d");

    class Paddle {
        INCREASE_Y = 0;
        DECREASE_Y = 1;

        constructor(xPosition, yPosition, radius) {
            this.xPosition = xPosition;
            this.yPosition = yPosition;
            this.radius = radius;
            this.yVelocity = 10;

        }

        draw() {
           // ctx.fillRect(this.xPosition, this.yPosition, this.width, this.height);
            ctx.beginPath();
            ctx.arc(this.xPosition, this.yPosition, this.radius, 0, Math.PI * 2, false);
            ctx.stroke();
        }

        move(direction) {

            const padding = 4;
            ctx.clearRect(
                this.xPosition - this.radius - padding,
                this.yPosition - this.radius - padding,
                (this.radius + padding) * 2,
                (this.radius + padding) * 2
            );


            switch (direction) {
                case this.INCREASE_Y:
                    if (this.yPosition + this.yVelocity >= canvas.height - this.radius) return;
                    this.yPosition += this.yVelocity;
                    break;
                case this.DECREASE_Y:
                    if (this.yPosition - this.yVelocity <= 0) return;
                    this.yPosition -= this.yVelocity;
                    break;
            }


            this.draw();
        }
    }

    class Ball {
        constructor(xPosition, yPosition, xVelocity, yVelocity, radius, rotation) {
            this.xPosition = xPosition;
            this.yPosition = yPosition;
            this.xVelocity = xVelocity;
            this.yVelocity = yVelocity;
            this.radius = radius;
            this.rotation = rotation;
            this.bounce = 0.9;
            this.spinspeed = 1;
        }

        getMaxHeight() {
            return overlayCanvas.height * this.distanceRemainder;
        }


        draw(overlayCtx) {
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            overlayCtx.beginPath();
            overlayCtx.arc(ball.xPosition, ball.yPosition, ball.radius, 0, 2 * Math.PI);
            overlayCtx.stroke();
            overlayCtx.save();

            // Everytime the ball is drawn, the peace symbol is also redrawn
            this.drawPeaceSymbol();

        }

        drawPeaceSymbol() {


            /*
            ball.xPosition = The center of the ball's x coordinate
            ball.yPosition = The center of the ball's y coordinate
            ball.radius = The length of the line, we want the line to be the same length as the center to the arc
            ball.rotation = How much we want to rotate the balk by up to 360 degree's
            ball.rotation * (Math.PI / 180) = Converts our rotation number to radians is degrees * PI / 180
             */
            let xEnd = ball.xPosition + ball.radius * Math.cos(ball.rotation * (Math.PI / 180));
            let yEnd = ball.yPosition + ball.radius * Math.sin(ball.rotation * (Math.PI / 180));
            overlayCtx.beginPath();
            overlayCtx.moveTo(ball.xPosition, ball.yPosition);
            overlayCtx.lineTo(xEnd, yEnd);
            overlayCtx.stroke();

            xEnd = ball.xPosition + ball.radius * Math.cos((180 + ball.rotation) * (Math.PI / 180));
            yEnd = ball.yPosition + ball.radius * Math.sin((180 + ball.rotation) * (Math.PI / 180));
            overlayCtx.beginPath();
            overlayCtx.moveTo(ball.xPosition, ball.yPosition);
            overlayCtx.lineTo(xEnd, yEnd);
            overlayCtx.stroke();

            xEnd = ball.xPosition + ball.radius * Math.cos((60 + ball.rotation) * (Math.PI / 180));
            yEnd = ball.yPosition + ball.radius * Math.sin((60 + ball.rotation) * (Math.PI / 180));
            overlayCtx.beginPath();
            overlayCtx.moveTo(ball.xPosition, ball.yPosition);
            overlayCtx.lineTo(xEnd, yEnd);
            overlayCtx.stroke();

            xEnd = ball.xPosition + ball.radius * Math.cos((295 + ball.rotation) * (Math.PI / 180));
            yEnd = ball.yPosition + ball.radius * Math.sin((295 + ball.rotation) * (Math.PI / 180));
            overlayCtx.beginPath();
            overlayCtx.moveTo(ball.xPosition, ball.yPosition);
            overlayCtx.lineTo(xEnd, yEnd);
            overlayCtx.stroke();

            this.rotation += this.spinspeed;


        }

        move() {

            this.yVelocity += 0.9;

            if (this.yPosition + this.radius >= yBorder) {
                this.yVelocity = -Math.abs(this.yVelocity) * this.bounce;
                this.yPosition = yBorder - this.radius;
            }

            if (this.xPosition + this.radius >= xBorder) {
                this.xVelocity = -Math.abs(this.xVelocity);
                this.xPosition = xBorder - this.radius;
            }

            if (this.yPosition - this.radius <= 0) {
                this.yVelocity = Math.abs(this.yVelocity);
                this.yPosition = this.radius;
            }

            if (this.xPosition - this.radius <= 0) {
                this.xVelocity = Math.abs(this.xVelocity);
                this.xPosition = this.radius;
            }

            this.yPosition += this.yVelocity;
            this.xPosition += this.xVelocity;
        }
    }
        const paddleOne = new Paddle(50, 50, 20);
    const paddleTwo = new Paddle(350, 50, 20);

    paddleOne.draw();
    paddleTwo.draw();

    $(document.body).on('keydown', function (e) {
        switch (e.which) {
            case 40:
                paddleOne.move(paddleOne.INCREASE_Y);
                break;
            case 38:
                paddleOne.move(paddleOne.DECREASE_Y);
                break;
            case 83:
                paddleTwo.move(paddleTwo.INCREASE_Y);
                break;
            case 87:
                paddleTwo.move(paddleTwo.DECREASE_Y);
                break;
            case 81:
                ball.spinspeed -= 1;
                break;
            case 69:
                ball.spinspeed += 1;
                break;
        }
    });


    function detectCollisions(ball, padOne, padTwo) {
        if(getDistance(ball.xPosition, ball.yPosition, padOne.xPosition, padOne.yPosition) <= ball.radius + padOne.width / 2){
            console.log("YES");
        }
    }

    function getDistance(x1,y1,x2,y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
    }



    window.addEventListener("mousemove", function (event) {
        let y = event.clientY;
        if (y >= 0 && y <= canvas.height - paddleOne.radius) {
            const padding = 2;
            ctx.clearRect(
                paddleOne.xPosition - paddleOne.radius - padding,
                paddleOne.yPosition - paddleOne.radius - padding,
                (paddleOne.radius + padding) * 2,
                (paddleOne.radius + padding) * 2
            );
            paddleOne.yPosition = y;
            paddleOne.draw();
            paddleTwo.draw();
            ball.draw();
        }
    });


    var ball = new Ball(150,150,3,3,10,0);

    var yBorder = canvas.height - ball.radius;
    var xBorder = canvas.width - ball.radius;

    function repeatme() {
        ball.draw(overlayCtx);
        ball.move()
        detectCollisions(ball, paddleOne, paddleTwo);
        window.requestAnimationFrame(repeatme);
    }

    repeatme();

</script>

</body>

</html>
